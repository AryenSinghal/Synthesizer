import tkinter as tk
import sounddevice as sd
import numpy as np
import scipy.signal as signal

def butter_lowpass(cutoff, fs, order=5):
    """
    Designs a low-pass Butterworth filter.

    Parameters:
    - cutoff (float): Cutoff frequency in Hz.
    - fs (float): Sampling rate in Hz.
    - order (int, optional): Filter order. Defaults to 5.

    Returns:
    - tuple: Numerator (b) and denominator (a) coefficients of the filter.
    """
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = signal.butter(order, normal_cutoff, btype='low', analog=False)
    return b, a

def butter_highpass(cutoff, fs, order=5):
    """
    Designs a high-pass Butterworth filter.

    Parameters:
    - cutoff (float): Cutoff frequency in Hz.
    - fs (float): Sampling rate in Hz.
    - order (int, optional): Filter order. Defaults to 5.

    Returns:
    - tuple: Numerator (b) and denominator (a) coefficients of the filter.
    """
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = signal.butter(order, normal_cutoff, btype='high', analog=False)
    return b, a

def generate_envelope(attack_time, decay_time, sustain_level, release_time, duration):
    """
    Generate an envelope for a sound waveform.

    Parameters:
    - attack_time (float): The duration of the attack phase in seconds.
    - decay_time (float): The duration of the decay phase in seconds.
    - sustain_level (float): The level of the sustain phase (between 0.0 and 1.0).
    - release_time (float): The duration of the release phase in seconds.
    - duration (float): The total duration of the envelope in seconds.

    Returns:
    - envelope (numpy.ndarray): The generated envelope as a 1-dimensional numpy array.

    The envelope is generated by combining four stages: attack, decay, sustain, and release.
    The attack phase is a linear increase from 0.0 to 1.0.
    The decay phase is an exponential decrease from 1.0 to the sustain level.
    The sustain phase is a constant level equal to the sustain level.
    The release phase is an exponential decrease from the sustain level to 0.0.

    The total number of samples in the envelope is determined by the duration and the sampling rate (44100 Hz).
    The envelope is truncated to ensure the correct number of samples.

    Example usage:
    envelope = generate_envelope(0.1, 0.2, 0.5, 0.3, 1.0)
    """

    sampling_rate = 44100
    total_samples = int(duration * sampling_rate)

    # Calculate number of samples for each stage
    attack_samples = int(attack_time * sampling_rate)
    decay_samples = int(decay_time * sampling_rate)
    sustain_samples = total_samples - attack_samples - decay_samples - int(release_time * sampling_rate)
    release_samples = int(release_time * sampling_rate)

    # Generate attack portion (linear increase)
    attack_envelope = np.linspace(0.0, 1.0, attack_samples)

    # Generate decay portion (exponential decrease)
    decay_envelope = np.linspace(1.0, sustain_level, decay_samples) ** (-1/decay_time)

    # Generate sustain portion (constant level)
    sustain_envelope = np.ones(sustain_samples) * sustain_level

    # Generate release portion (exponential decrease)
    release_envelope = np.linspace(sustain_level, 0.0, release_samples) ** (-1/release_time)

    # Combine all stages into the final envelope
    envelope = np.concatenate((attack_envelope, decay_envelope, sustain_envelope, release_envelope))

    return envelope[:total_samples]  # Ensure correct number of samples

def generate_waveform(wave_type, frequency, duration, envelope):
    """
    Generate a waveform based on the given parameters.

    Parameters:
        wave_type (str): The type of waveform to generate. Valid options are "sine" and "square".
        frequency (float): The frequency of the waveform in Hz.
        duration (float): The duration of the waveform in seconds.
        envelope (numpy.ndarray): The envelope to apply to the waveform.

    Returns:
        numpy.ndarray: The generated waveform as an array of samples.

    """
    # Set sampling rate
    sampling_rate = 44100
    t = np.linspace(0, duration, int(duration*sampling_rate))

    if wave_type == "sine":
        samples = np.sin(2*np.pi*frequency*t)
    elif wave_type == "square":
        samples = np.sign(np.sin(2*np.pi*frequency*t))
    else:
        samples = np.sin(2*np.pi*frequency*t)  # Default to sine
    
    # Apply envelope to the samples
    samples *= envelope

    return samples.astype(np.float32)

def apply_filter(samples, filter_type, cutoff_frequency):
    """
    Applies a low-pass or high-pass filter to the audio samples.

    Parameters:
    - samples (numpy.ndarray): Audio samples.
    - filter_type (str): "lowpass" or "highpass".
    - cutoff_frequency (float): Cutoff frequency in Hz.

    Returns:
    - numpy.ndarray: Filtered audio samples.
    """
    sampling_rate = 44100
    if filter_type == "lowpass":
        b, a = butter_lowpass(cutoff_frequency, sampling_rate)
    elif filter_type == "highpass":
        b, a = butter_highpass(cutoff_frequency, sampling_rate)
    else:
        return samples  # No filter applied

    return signal.filtfilt(b, a, samples)

def play_note(frequency, duration, wave_type, attack_time, decay_time, sustain_level, release_time, filter_type, cutoff_frequency):
    """
    Play a note with the given parameters.

    Args:
        frequency (float): The frequency of the note in Hz.
        duration (float): The duration of the note in seconds.
        wave_type (str): The type of waveform to generate.
        attack_time (float): The attack time of the note in seconds.
        decay_time (float): The decay time of the note in seconds.
        sustain_level (float): The sustain level of the note.
        release_time (float): The release time of the note in seconds.

    Returns:
        None
    """
    samples = generate_waveform(wave_type, frequency, duration, generate_envelope(attack_time, decay_time, sustain_level, release_time, duration))
    samples = apply_filter(samples, filter_type, cutoff_frequency)
    sd.play(samples, samplerate=44100)

def button_clicked(wave_type):
    """
    Plays a note with the given parameters.

    Args:
        wave_type (str): The type of waveform to use for the note.

    Returns:
        None
    """
    frequency = float(frequency_entry.get())
    duration = float(duration_entry.get())
    attack_time = attack_slider.get()
    decay_time = decay_slider.get()
    sustain_level = sustain_slider.get()
    release_time = release_slider.get()

    # Add filter selection and cutoff frequency entry/slider
    filter_type = filter_var.get()  # Get filter type from radio buttons
    cutoff_frequency = float(cutoff_entry.get())  # Get cutoff frequency from entry

    play_note(frequency, duration, wave_type, attack_time, decay_time, sustain_level, release_time, filter_type, cutoff_frequency)

window = tk.Tk()
window.title("Simple Synthesizer")

frequency_label = tk.Label(window, text="Frequency (Hz):")
frequency_label.pack()

frequency_entry = tk.Entry(window)
frequency_entry.pack()

duration_label = tk.Label(window, text="Duration (seconds):")
duration_label.pack()

duration_entry = tk.Entry(window)
duration_entry.pack()

# ADSR Sliders
attack_label = tk.Label(window, text="Attack (s):")
attack_label.pack()

attack_slider = tk.Scale(window, from_=0.0, to_=1.0, orient=tk.HORIZONTAL, resolution=0.01)
attack_slider.set(0.1)  # Default value
attack_slider.pack()

decay_label = tk.Label(window, text="Decay (s):")
decay_label.pack()

decay_slider = tk.Scale(window, from_=0.0, to_=1.0, orient=tk.HORIZONTAL, resolution=0.01)
decay_slider.set(0.2)  # Default value
decay_slider.pack()

sustain_label = tk.Label(window, text="Sustain Level:")
sustain_label.pack()

sustain_slider = tk.Scale(window, from_=0.0, to_=1.0, orient=tk.HORIZONTAL, resolution=0.01)
sustain_slider.set(0.5)  # Default value
sustain_slider.pack()

release_label = tk.Label(window, text="Release (s):")
release_label.pack()

release_slider = tk.Scale(window, from_=0.0, to_=1.0, orient=tk.HORIZONTAL, resolution=0.01)
release_slider.set(0.3)  # Default value
release_slider.pack()

# Filter selection using radio buttons
filter_var = tk.StringVar()
filter_var.set("no_filter")  # Default selection (no filter)
filter_label = tk.Label(window, text="Filter:")
filter_label.pack()

lowpass_button = tk.Radiobutton(window, text="Low Pass", variable=filter_var, value="lowpass")
lowpass_button.pack()

highpass_button = tk.Radiobutton(window, text="High Pass", variable=filter_var, value="highpass")
highpass_button.pack()

# Cutoff frequency entry
cutoff_label = tk.Label(window, text="Cutoff Frequency (Hz):")
cutoff_label.pack()

cutoff_entry = tk.Entry(window)
cutoff_entry.pack()

# Create buttons for waveforms
sine_button = tk.Button(window, text="Sine", command=lambda: button_clicked("sine"))
sine_button.pack()

square_button = tk.Button(window, text="Square", command=lambda: button_clicked("square"))
square_button.pack()

window.mainloop()
